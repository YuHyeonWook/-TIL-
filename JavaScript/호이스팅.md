# 호이스팅(**Hoisting)**

- **호이스팅**은 **변수 선언과 함수 선언을 코드의 맨 위로 끌어올려지는 현상**을 말한다.
- 또한, 호이스팅의 발생 원인은 자바스크립트의 **선언과 초기화**가 분리되어 진행된다.
  - 즉, 변수가 함수 내에서 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 변경된다.
- var, let, const, function, class 키워드를 사용해 선언된 모든 식별자(변수, 함수, 클래스)는 호이스팅 된다.

## 예제

### 1) 변수 호이스팅)

```
console.log(a);  // undefined
var a = 1;

console.log(a);  // 1

console.log(b);  // ReferenceError: Cannot access 'a' before initialization
let b = 2;
```

- 위 코드를 살펴보면, a가 console.log 앞에 선언되어 있지 않지만, 밑에 있는 변수 a를 맨 위로 끌어올려와  undefined라는 값을 불러올 수 있다.
- let 역시 호이스팅 되지만, 콘솔창에는 b를 찾을 수 없다는 **참조에러(ReferenceError)**가 뜬다.
- let이 호이스팅 안 되어서 에러가 뜨는 것으로 생각할 수도 있지만,  **초기화(initialization) 전에 접근(access)할 수 없다고** 에러가 나온다.
- 즉, **let 변수**는 호이스팅으로 인해 **선언되어 있지만**, **TDZ(일시적 사각지대)로 인해** 아직 **초기화가 되지 않아** 접근이 안 되는 것이다.

변수는 3단계에 걸쳐서 생성된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/cdf5fd00-85a4-4001-aa3d-4b52542685d0/f824f37b-c0df-4e8d-83a1-3a9ee9994052/Untitled.png)

1. 선언 단계 : 변수를 (실행 컨텍스트의) 변수 객체에 등록한다. 즉, 변수가 등록(선언)된 것이다
2. 초기화 단계 : 변수에 값을 넣기 위한 공간을 메모리에 확보한다. 이 단계에서 변수는 undefined로 초기화된다.
3. 할당 단계 : undefined로 초기화된 변수에 실제 값을 넣어준다.

- var변수는 선언과 초기화가 한 번에 이루어진다. 그렇기에 변수 a의 값을 불러오기 위해 접근했을 때, 아직 실제 값이 "할당"되지는 않았지만, **undefined**라는 값을 불러올 수 있는 것이다.
- 반면, let과 const는 선언과 초기화 단계 사이에 **TDZ(일시적 사각지대)**라는 것이 존재한다.
- 아직 선언도 안 되어 있는데 접근한다면 심각한 에러가 발생할 수 있기에 이를 막기 위해 TDZ라는 것을 만들어 두었다.

### 2-1) 함수 호이스팅

자바스크립트 함수를 정의하는 문법으로 **함수 표현식**과 **함수 선언식** 두 가지가 있다.

```
// 함수 선언식
function add(x, y) {
  return x + y;
}

// 함수 표현식
const add = function(x, y) {
  return x + y;
};
```

- 이 둘은 결국 함수를 만드는데 기본적으로 동일한 기능을 수행하지만,  **함수 표현식**은 함수를 변수에 할당하므로 유연성이 높고, **호이스팅이 강제적**으로 되지 않아 개발자로 하여금 혼동을 주지 않음.

```
// 함수 참조
console.log(sum);  // f sum(x, y)

// 함수 호출
console.log(sum(6, 8));  // 14

// 함수 선언문
function sum(x, y) {
  return x + y;
};
```

- 위 코드를 살펴보면, 함수 sum 역시 맨 위에 선언이 되어있지 않지만, **함수를 참조하고 호출할 수 있다**.
- 이는 런타임 이전에 함수 이름과 동일한 이름의 식별자를 생성해 함수 객체에 할당해두기 때문에 가능하다.

* 런타임(runtime) : 코드가 한 줄씩 실행되는 시점

### **2-2) 함수 표현식**

```
// 함수 참조
console.log(sum);  // undefined

// 함수 호출
console.log(sum(6, 8));  // TypeError: sum is not a function

// 함수 표현식
var sum = function (x, y) {
  return x + yield;
};
```

- 함수 표현식으로 함수를 호출했을 경우엔 **타입에러(TypeError)**가 뜬다.
- 함수의 타입은 **객체**이며, 이러한 **객체 값(함수)을 변수에 할당해주는 방식**이 **함수 표현식**이다.
- 함수 표현식은 함수 선언문과 달리 타입 에러가 뜬다. 그 이유는 **실제 함수 값을 console.log 이전에 할당해주지 않았기 때문에 undefined라는 값을 출력하고, sum의 타입은 undefined이기에 sum의 타입이 함수가 아니라는 에러 메시지가 뜨는 것**이다**.**

### **3) 함수 표현식 권장이유**

함수 선언식 예시)

```
console.log(add(2, 3));

function add(x, y) {
    return x + y;
}

console.log(add(3, 4));

// >> 5
// >> 7
```

- add(2,3)은 아직 function add() 함수가 정의되지 않았음에도 불구하고 add() 함수를 호출하는 것이 가능함. 왜냐면 코드 해석 단계에서 호이스팅이 일어나 function add()가 상단으로 끌어올려졌기 때문이다.
- 이러한 구조는 함수를 선언하기 전에 함수를 선언하는 것이기 때문에 코드의 구조를 엉성하게 만들 수 있다. 그래서 함수 표현식만을 사용하라고 권장함.

```
console.log(add(2, 3));  // error

// 함수 표현식 형태로 add() 함수 정의
var add = function (x, y) {
    return x + y;

}

console.log(add(3, 4));  // 7
```

- 처음의 ~~add(2, 3)~~ 함수는 실행되지 않는다. 함수 표현식 형태로 add() 함수가 정의되어 있기 때문에 호이스팅이 일어나지 않음

## 변수 호이스팅과 함수 호이스팅 공통점과 차이점

- 공통점: 변수 호이스팅과 함수 호이스팅은 런타임 이전에 실행되어 식별자를 생성한다는 점에서 동일하다
- 차이점: var 변수는 undefined로 초기화되고, 함수 식별자는 함수 객체로 초기화된다.
  - 따라서 var 변수를 참조하면 undefined로 평가되지만, 함수 선언문 이전에 함수를 호출할 수 있다.

</br>

# 참고

https://valueengine.tistory.com/m/15

https://poiemaweb.com/es6-block-scope

https://www.youtube.com/watch?v=SBTyD_fLZnE
