# HTTP 헤더 개요

---

## 용도

- HTTP 전송에 필요한 모든 부가정보를 넣는다.
  ⇒ 메시지 바디의 내용, 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보 등
- 필요하다면 임의의 헤더 추가도 가능하다.
  ⇒ helloworld: hihi

## 분류

과거에는 어떻게 분류를 했을까?

https://developer.mozilla.org/docs/Web/HTTP/Messages

- General헤더: 요청 메세지/ 응답메시지 구분 없이 메세지 전체에 적용되는 정보
- Request 헤더: 요청을 보낼때 들어가는 헤더
  _⇒User-Agent:Mozilla/5.0(Macintosh;..)_
- Response 헤더: 응답할 때 들어가는 헤더
  _⇒ Server: Apache_
- **Entity 헤더: 엔티티 바디 정보로 컨텐츠 타입이나 길이같은 메세지 바디에 들어가는 내용에 관련된 헤더가 들어가는 헤더**

## HTTP BODY

messagaae body - RFC2616(과거)

- **메세지 본문(message body)은 엔티티 본문(entity body)를 전달하는데 사용한다.**
- **엔티티 본문은 요청이나 응답에서 전달할 실제 데이터를 의미한다.**
- **엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보를 제공한다.**
  ⇒ 데이터 유형(html, json), 데이터 길이, 압축 정보 등

### BUT

이런 엔티티 헤더 스펙은 1999년 RFC2616 스펙에서 나온 스펙인데, 이 스펙은 2014년 RFC7230~7235가 등장하면서 폐기된다. 그 이후 엔티티라는 표현은 표현이라는 용어가 사용된다.

`엔티티(Entity) → 표현(Representation)`

`Representation` = `representation Metadata` + `Representation Data`

즉, 표현 메타데이터와 표현 데이터를 합쳐 표현이라 부른다.

그럼 이제 최신 스펙에서는 메시지 바디가 어떻게 되있는지 살펴보자.

### Message Body - RFC7230(최신)

- 메시지 본문을 통해 표현 데이터 전달
- 메세지 본문 = Payload
- 표현은 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.
  ⇒ 데이터 유형(html, json), 데이터 길이, 압축 정보 등
- 참고: 표현 헤더는 표현 메타데이터와, 페이로드 메시지를 구분해야하지만, 너무 복잡해지기에 생략

### 정리

어째서 엔티티를 표현이라고 바꿔서 말하는 것일까?

예를들어 회원 조회 내역을 응답할 때 이를 HTML로 표현할 수도 있고, JSON으로 표현해 전달할 수도 있다. 그래서 이렇게 실제 전달하는 것을 표현이라고 용어를 정의했다.

이제는 이 표현(Representation)에 대해 더 알아보자.

</br>

# 표현

---

회원이라는 리소스가 있을 때 이를 HTML 혹은 JSON으로 전달할꺼야 라는 클라이언트와 서버간에 송/수신할 때 이 리소스를 무엇으로 표현할지 알려주고, 표현한다.

- `Content-Type`: 표현 데이터의 형식
- `Content-Encoding`: 표현 데이터의 압축 방식
- `Content-Language`: 표현 데이터의 자연 언어
- `Content-Length`: 표현 데이터의 길이
  ⇒ 표현 헤더라기보다는 Payload 헤더라고 부르는게 명확하지만 심플하게 표현헤더로 생각해도 된다.
- 표현 헤더는 전송, 응답 둘 다 사용한다.

### Content-Type

표현 데이터의 형식 설명

- 미디어 타입, 문자 인코딩
  - text/html; charset=utf-8
  - application/json (기본이 utf-8)
  - image/png

### Content-Encoding

:표현 데이터 인코딩

- 표현 데이터를 압축하기 위해 사용한다.
- 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
- 데이터를 읽는 쪽에서 인코딩 헤더 정보로 압축 해제
  - gzip
  - deflate
  - identity (압축을 하지않는다는 의미)

### Content-Language

표현 데이터의 자연 언어

- 표현 데이터의 자연 언어를 표현
  - ko
  - en
  - en-US
- 해당 헤더를 통해 국가별로 맞는 언어로(지원한다는 가정하에) 응답을 받을 수 있다.

### Content-Length

표현 데이터의 길이

- 바이트 단위
- Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안된다.

</br>

# 인증

---

## Authorization

클라이언트 인증 정보를 서버에 전달

- **Authorization: BASIC xxxxxxxxxxxxxxxxxx**
  - _인증 방식은 OAuth, OAuth2, SNS로그인 등 다양한데, 그런 방식별로 들어가야하는 값이 다르다._
  - _인증 메커니즘과는 상관없이 헤더를 제공하는 것으로 인증과 관련된 값을 넣어주면 된다._

## WWW-Authentication

리소스 접근시 필요한 인증 방법 정의

- 리소스 접근시 필요한 인증 방법 정의
- 401 Unauthorized 응답과 함꼐 사용한다.
- WW-Authentication: Newauth realm="apps", type=1,title="Login to \"apps\"", Basic realm="simple"
  ⇒ 위와같은 방식으로 어떻게 인증을 해야할지를 정의해 알려준다.

</br>

# 쿠키

---

## 쿠키란?

: HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은데이터 조각으로 브라우저는 이 데이터 조각들을 저장해 놓았다가 동일한 서버에 재 요청시 저장된 데이터를 함께 전송한다.

- **Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)**
- **Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달한다.**

## 주 사용 목적

1. 세션 관리(Session Management)

   ⇒ 서버에 저장해야 할 로그인, 장바구니, 게임 스코어등의 정보 관리

2. 개인화(Personalization)

   ⇒ 사용자 선호, 테마 등의 세팅

3. 트래킹(Tracking)

   ⇒ 사용자 행동을 기록하고 분석하는 용도

## 쿠키를 사용하지 않았을때의 불편함

### 로그인

- 클라이언트에서 POST 메서드로 로그인을 한 상태이다.
- 그럼 여기서 다시 welcome과 같은 페이지로 이동한다.
  ⇒ 내가 기대하는 화면은 로그인한 나를 알고 있기를 바라지만...

### 로그인 이후 /welcome

- 서버입장에서는 이게 로그인한 유저가 보낸 요청인지 알 수 없다.
- 그렇기에 게스트(비회원)로 판단해서 응답을 할 수밖에 없다.
- HTTP는 무상태 프로토콜(Stateless Protocol)이라는 점을 기억해야 한다.

## Stateless

- 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.
- 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
- 클라이언트와 서버는 서로 상태를 유지하지 않는다.

## 대안은?

### 1. 모든 요청에 사용자 정보를 포함

- 매번 요청할 때마다 로그인한 유저의 정보를 담아서 보내주면 서버측에서는 해당 정보를 분석해 로그인상태를 확인한다.
- 모든 요청과 링크에 사용자 정보를 포함해야하기에 비용소모가 몹시 크다.

  모든 요청에 로그인정보를 포함한다.

- 브라우저를 완전히 종료 후 다시 열면 정보를 포함할 수 없다.

### 2. 쿠키를 사용한다.

- 클라이언트에서 로그인을 요청하며 데이터를 보내면 서버에서는 Set-Cookie로 로그인 정보를 담아 응답한다.
- 웹브라우저는 내장된 쿠키 저장소에 Set-Cookie에 있는 정보를 저장한다.
- 그래서 로그인 이후 welcome 페이지에 접근하면 쿠키를 조회해서 쿠키값을 Cookie에 담아서 보낸다.

- 하지만 이렇게 매번 쿠키를 담아 보내는 것도 문제가 있다.

## 쿠키의 사용처 및 사용시 주의점

- **사용처**
  - _사용자 로그인 세션 관리_
  - _광고 정보 트래킹_
- **쿠키 정보는 항상 서버에 전송된다.**
  - _네트워크 트래픽을 추가적으로 유발한다._
  - _최소한의 정보만 사용해야 한다(세션, id, 인증 토큰)_
  - _서버에 전송하지 않고 웹 브라우저 내부에 데이터를 저장하고 싶은 경우 웹스토리지를 사용_
- **주의점**
  - _보안에 민감한 데이터는 저장하면 안된다._
    _⇒ 주민번호, 신용카드 번호 등_

## 쿠키의 생명주기(LifeCycle)

Expires, max-age

- Set-Cookie: expires=Sat, 26-Dec-2020 04:39:21 GMT
  ⇒ 만료일이 되면 쿠키는 삭제된다.
- Set-Cookie: max-age=3600(3600초)
  - 0이나 음수로 지정할 경우 쿠키는 삭제된다.
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지된다.
- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지된다.

## 쿠키 도메인 지정

<aside>
💡 domain=example.org

</aside>

- 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함
  ⇒ domain=example.org로 지정해서 쿠키를 생성하면
  ⇒ [`example.org`](http://example.org) → 쿠키 접근가능
  ⇒`dev.example.org` → 쿠키접근 가능
- 생략: 현재 문서 기준 도메인만 적용
  ⇒ [`example.org`](http://example.org) 에서 쿠키를 생성하고 domain 지정을 생략하면
  ⇒ [`example.org`](http://example.org) 에서만 쿠키 접근이 가능하다.
  ⇒ `dev.example.org`는 쿠키 접근이 불가하다.

## 쿠키 경로 지정

<aside>
💡 path=/home

</aside>

- 작성한 경로를 포함한 하위 경로 페이지에서만 쿠키 접근이 가능하다.
- 일반적으로 path=/ 루트로 지정한다
  - 해당 도메인의 하위 경로 모두 쿠키를 사용하기를 바라기 때문
  - 예)
    ⇒ path=/home 지정
    ⇒ /home/level1 접근 가능
    ⇒ /home/level1/level2 접근 가능
    ⇒ /hello 불가능

## 쿠키 보안 `Secure`, `HttpOnly`, `SameSite`

- **`Secure`**
  - 쿠키는 http, https를 구분하지 않고 전송한다.
  - Secure를 적용하면 https인 경우에만 전송한다.
- **`HttpOnly`**
  - XSS 공격 방지
  - 자바스크립트에서 접근 불가(document.cookie)
  - HTTP 전송에만 사용한다.
- **`SameSite`**
  - XSRF공격 방지
  - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송한다.
